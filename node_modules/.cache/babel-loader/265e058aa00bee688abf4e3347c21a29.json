{"ast":null,"code":"var _jsxFileName = \"/Users/ovidiufritsch/code/tennis_atp/atp_frontend/src/components/AgeComparison/Graph.js\";\nimport React from 'react';\nimport { Line } from 'react-chartjs-2';\n\nclass Graph extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      datasets: [],\n      labels: [],\n      start_age: 20,\n      end_age: 30,\n      available_colors: Graph.colors\n    };\n  }\n\n  generate_color() {\n    var o = Math.round,\n        r = Math.random,\n        s = 255;\n    return 'rgba(' + o(r() * s) + ',' + o(r() * s) + ',' + o(r() * s) + ',' + 1 + ')';\n  }\n\n  create_dataset(ranks, player_name, player_id, color) {\n    var res = {\n      data: {\n        label: player_name,\n        fill: false,\n        lineTension: 0.1,\n        backgroundColor: color,\n        borderColor: color,\n        borderCapStyle: 'butt',\n        borderDash: [],\n        borderDashOffset: 0.0,\n        borderJoinStyle: 'miter',\n        pointBorderColor: color,\n        pointBackgroundColor: '#fff',\n        pointBorderWidth: 1,\n        pointHoverRadius: 5,\n        pointHoverBackgroundColor: color,\n        pointHoverBorderColor: 'rgba(220,220,220,1)',\n        pointHoverBorderWidth: 2,\n        pointRadius: 1,\n        pointHitRadius: 10,\n        data: ranks\n      },\n      player_id: player_id,\n      player_name: player_name\n    };\n    return res;\n  } // http GET to flask api to fetch ranking history of player with id=p_id between ages of s and e\n\n\n  fetch_ranking_history(p_id, s, e) {\n    var endpt = \"/get_ranking_history?player_id=\".concat(p_id, \"&starting_age=\").concat(s, \"&ending_age=\").concat(e);\n    return fetch(endpt);\n  }\n\n  changeAgeRange(start, end) {\n    // if any part of the interval of the new range is in the old range,\n    // then we don't necessarily need to refetch this data. but for now\n    // to keep things simple, just refetch everything\n    var old_colors = this.state.datasets.map(x => x['data']['backgroundColor']);\n    var player_ids = this.state.datasets.map(x => x['player_id']);\n    var player_names = this.state.datasets.map(x => x['player_name']);\n    var new_labels = [];\n    var new_datasets = [];\n\n    const request = async idx => {\n      if (idx >= player_ids.length) {\n        this.setState({\n          datasets: new_datasets,\n          labels: new_labels,\n          start_age: start,\n          end_age: end\n        });\n        return;\n      }\n\n      var endpt = \"/get_ranking_history?player_id=\".concat(player_ids[idx], \"&starting_age=\").concat(start, \"&ending_age=\").concat(end);\n      const response = await fetch(endpt);\n      const data = await response.json();\n      var ranks = data['data'].map(x => x['rank']);\n      var labels = data['data'].map(x => x['age']);\n\n      if (labels.length > new_labels.length) {\n        new_labels = labels;\n      }\n\n      new_datasets.push(this.create_dataset(ranks, player_names[idx], player_ids[idx], old_colors[idx]));\n      request(idx + 1);\n    };\n\n    request(0);\n  }\n\n  removePlayer(player_id) {\n    var new_available_colors = this.state.available_colors;\n\n    for (var i = 0; i < this.state.datasets.length; i++) {\n      if (this.state.datasets[i]['player_id'] === player_id) {\n        new_available_colors.unshift(this.state.datasets[i]['data']['backgroundColor']);\n      }\n    } // set the new labels to be the labels of maximum length without the one that's being removed\n    // we don't store all the other labels though...\n\n\n    this.setState({\n      datasets: this.state.datasets.filter(x => x['player_id'] !== player_id),\n      available_colors: new_available_colors\n    });\n  }\n\n  addPlayer(player_id, player_name) {\n    // first check to see if this player has already been added\n    if (this.state.datasets.map(x => x['player_id']).includes(player_id)) {\n      return;\n    }\n\n    var promise = this.fetch_ranking_history(player_id, this.state.start_age, this.state.end_age);\n    promise.then(response => response.json().then(data => {\n      var ranks = data['data'].map(x => x['rank']);\n      var new_labels = data['data'].map(x => x['age']);\n\n      if (new_labels.length < this.state.labels.length) {\n        new_labels = this.state.labels;\n      }\n\n      var color;\n\n      if (this.state.available_colors.length == 0) {\n        color = this.generate_color();\n      } else {\n        color = this.state.available_colors[0];\n      }\n\n      var new_available_colors = [];\n\n      if (this.state.available_colors.length > 1) {\n        new_available_colors = this.state.available_colors.slice(1);\n      }\n\n      this.setState({\n        labels: new_labels,\n        datasets: [...this.state.datasets, this.create_dataset(ranks, player_name, player_id, color)],\n        available_colors: new_available_colors\n      });\n    }));\n  } // we want to display at most 12 ticks\n\n\n  get_tick(value) {}\n\n  render() {\n    console.log(this.state.end_age);\n    const datasets = this.state.datasets.map(x => x['data']);\n    const options = {\n      scales: {\n        xAxes: [{\n          ticks: {\n            display: true,\n            maxTicksLimit: 12,\n            autoSkip: false,\n            callback: function (value, index, values) {\n              var get_month = val => {\n                val = val - Math.floor(val);\n                return Math.ceil(12 * val);\n              }; // return Math.floor(value).toString() + \"yrs\" + get_month(value).toString()\n\n\n              var num_vals = values.length;\n              var step = Math.floor(values.length / 12);\n\n              if (index % step == 0) {\n                return \"tick\";\n              } else {\n                return \"\";\n              } // var age_diff = this.state.end_age - this.state.start_age\n              // var step = age_diff / 12\n\n            }\n          }\n        }]\n      }\n    };\n    const data = {\n      labels: this.state.labels,\n      datasets: datasets\n    };\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 205\n      },\n      __self: this\n    }, React.createElement(Line, {\n      data: data,\n      options: options,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 206\n      },\n      __self: this\n    }));\n  }\n\n}\n\nGraph.colors = ['rgb(76, 128, 24, 1)', 'rgb(24, 76, 128, 1)', 'rgb(128, 24, 128, 1)', 'rgb(216, 12, 12, 1)', 'rgb(225, 122, 19, 1)', 'rgb(19, 225, 225, 1)', 'rgb(68, 97, 39, 1)', 'rgb(97, 39, 39, 1)'];\nexport default Graph;","map":{"version":3,"sources":["/Users/ovidiufritsch/code/tennis_atp/atp_frontend/src/components/AgeComparison/Graph.js"],"names":["React","Line","Graph","Component","constructor","props","state","datasets","labels","start_age","end_age","available_colors","colors","generate_color","o","Math","round","r","random","s","create_dataset","ranks","player_name","player_id","color","res","data","label","fill","lineTension","backgroundColor","borderColor","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","pointBorderColor","pointBackgroundColor","pointBorderWidth","pointHoverRadius","pointHoverBackgroundColor","pointHoverBorderColor","pointHoverBorderWidth","pointRadius","pointHitRadius","fetch_ranking_history","p_id","e","endpt","fetch","changeAgeRange","start","end","old_colors","map","x","player_ids","player_names","new_labels","new_datasets","request","idx","length","setState","response","json","push","removePlayer","new_available_colors","i","unshift","filter","addPlayer","includes","promise","then","slice","get_tick","value","render","console","log","options","scales","xAxes","ticks","display","maxTicksLimit","autoSkip","callback","index","values","get_month","val","floor","ceil","num_vals","step"],"mappings":"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","sourcesContent":["import React from 'react';\nimport {Line} from 'react-chartjs-2';\n\nclass Graph extends React.Component {\n\tconstructor(props) {\n\t\tsuper(props)\n\t\tthis.state = {\n\t\t\tdatasets: [],\n\t\t\tlabels: [],\n\t\t\tstart_age: 20,\n\t\t\tend_age: 30,\n\t\t\tavailable_colors: Graph.colors\n\t\t}\n\t}\n\n\tstatic colors = [\n\t\t'rgb(76, 128, 24, 1)',\n\t\t'rgb(24, 76, 128, 1)',\n\t\t'rgb(128, 24, 128, 1)',\n\t\t'rgb(216, 12, 12, 1)',\n\t\t'rgb(225, 122, 19, 1)',\n\t\t'rgb(19, 225, 225, 1)',\n\t\t'rgb(68, 97, 39, 1)',\n\t\t'rgb(97, 39, 39, 1)'\n\t]\n\n\tgenerate_color() {\n\t\tvar o = Math.round, r = Math.random, s = 255;\n\t\treturn 'rgba(' + o(r()*s) + ',' + o(r()*s) + ',' + o(r()*s) + ',' + 1 + ')';\n\t}\n\n\tcreate_dataset(ranks, player_name, player_id, color) {\n\t\tvar res =\n\t\t{\n\t\t\tdata: {\n\t\t\t\tlabel: player_name,\n\t\t\t\tfill: false,\n\t\t\t\tlineTension: 0.1,\n\t\t\t\tbackgroundColor: color,\n\t\t\t\tborderColor: color,\n\t\t\t\tborderCapStyle: 'butt',\n\t\t\t\tborderDash: [],\n\t\t\t\tborderDashOffset: 0.0,\n\t\t\t\tborderJoinStyle: 'miter',\n\t\t\t\tpointBorderColor: color,\n\t\t\t\tpointBackgroundColor: '#fff',\n\t\t\t\tpointBorderWidth: 1,\n\t\t\t\tpointHoverRadius: 5,\n\t\t\t\tpointHoverBackgroundColor: color,\n\t\t\t\tpointHoverBorderColor: 'rgba(220,220,220,1)',\n\t\t\t\tpointHoverBorderWidth: 2,\n\t\t\t\tpointRadius: 1,\n\t\t\t\tpointHitRadius: 10,\n\t\t\t\tdata: ranks,\n\t\t\t},\n\n\t\t\tplayer_id: player_id,\n\t\t\tplayer_name: player_name\n\t\t}\n\n\t\treturn res\n\t}\n\n\t// http GET to flask api to fetch ranking history of player with id=p_id between ages of s and e\n\tfetch_ranking_history(p_id, s, e) {\n\t\tvar endpt = `/get_ranking_history?player_id=${p_id}&starting_age=${s}&ending_age=${e}`\n\t\treturn fetch(endpt)\n\t}\n\n\tchangeAgeRange(start, end) {\n\t\t// if any part of the interval of the new range is in the old range,\n\t\t// then we don't necessarily need to refetch this data. but for now\n\t\t// to keep things simple, just refetch everything\n\t\tvar old_colors = this.state.datasets.map(x => x['data']['backgroundColor'])\n\t\tvar player_ids = this.state.datasets.map(x => x['player_id'])\n\t\tvar player_names = this.state.datasets.map(x => x['player_name'])\n\t\tvar new_labels = [];\n\t\tvar new_datasets = [];\n\n\t\tconst request = async(idx) => {\n\t\t\tif (idx >= player_ids.length) {\n\t\t\t\tthis.setState({\n\t\t\t\t\tdatasets: new_datasets,\n\t\t\t\t\tlabels: new_labels,\n\t\t\t\t\tstart_age: start,\n\t\t\t\t\tend_age: end\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar endpt = `/get_ranking_history?player_id=${player_ids[idx]}&starting_age=${start}&ending_age=${end}`\n\t\t\tconst response = await fetch(endpt);\n\t\t\tconst data = await response.json();\n\t\t\tvar ranks = data['data'].map(x => x['rank'])\n\t\t\tvar labels = data['data'].map(x => x['age'])\n\t\t\tif (labels.length > new_labels.length) {\n\t\t\t\tnew_labels = labels\n\t\t\t}\n\t\t\tnew_datasets.push(this.create_dataset(ranks, player_names[idx], player_ids[idx], old_colors[idx]))\n\t\t\trequest(idx + 1)\n\t\t}\n\n\t\trequest(0)\n\t}\n\n\tremovePlayer(player_id) {\n\t\tvar new_available_colors = this.state.available_colors;\n\t\tfor (var i = 0; i < this.state.datasets.length; i++) {\n\t\t\tif (this.state.datasets[i]['player_id'] === player_id) {\n\t\t\t\tnew_available_colors.unshift(this.state.datasets[i]['data']['backgroundColor'])\n\t\t\t}\n\t\t}\n\n\t\t// set the new labels to be the labels of maximum length without the one that's being removed\n\t\t// we don't store all the other labels though...\n\n\t\tthis.setState({\n\t\t\tdatasets: this.state.datasets.filter(x => x['player_id'] !== player_id),\n\t\t\tavailable_colors: new_available_colors\n\t\t})\n\t}\n\n\taddPlayer(player_id, player_name) {\n\n\t\t// first check to see if this player has already been added\n\t\tif (this.state.datasets.map(x => x['player_id']).includes(player_id)) {\n\t\t\treturn\n\t\t}\n\n\t\tvar promise = this.fetch_ranking_history(player_id, this.state.start_age, this.state.end_age)\n\t\tpromise.then(response => response.json().then(data => {\n\t\t\tvar ranks = data['data'].map(x => x['rank'])\n\t\t\tvar new_labels = data['data'].map(x => x['age'])\n\t\t\tif (new_labels.length < this.state.labels.length) {\n\t\t\t\tnew_labels = this.state.labels\n\t\t\t}\n\t\t\tvar color;\n\t\t\tif (this.state.available_colors.length == 0) {\n\t\t\t\tcolor = this.generate_color()\n\t\t\t} else {\n\t\t\t\tcolor = this.state.available_colors[0]\n\t\t\t}\n\t\t\tvar new_available_colors = [];\n\t\t\tif (this.state.available_colors.length > 1) {\n\t\t\t\tnew_available_colors = this.state.available_colors.slice(1)\n\t\t\t}\n\n\t\t\tthis.setState({\n\t\t\t\tlabels: new_labels,\n\t\t\t\tdatasets: [...this.state.datasets, this.create_dataset(ranks, player_name, player_id, color)],\n\t\t\t\tavailable_colors: new_available_colors\n\t\t\t})\n\t\t}))\n\t}\n\n\t// we want to display at most 12 ticks\n\tget_tick(value) {\n\t}\n\n\trender() {\n\t\tconsole.log(this.state.end_age)\n\n\t\tconst datasets = this.state.datasets.map(x => x['data'])\n\n\t\tconst options = {\n\t\t\tscales: {\n\t\t\t\txAxes: [{\n\t\t\t\t\tticks: {\n\t\t\t\t\t\tdisplay: true,\n\t\t\t\t\t\tmaxTicksLimit: 12,\n\t\t\t\t\t\tautoSkip: false,\n\t\t\t\t\t\tcallback: function(value, index, values) {\n\n\t\t\t\t\t\t\tvar get_month = (val) => {\n\t\t\t\t\t\t\t\tval = val - Math.floor(val)\n\t\t\t\t\t\t\t\treturn Math.ceil(12 * val)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// return Math.floor(value).toString() + \"yrs\" + get_month(value).toString()\n\n\t\t\t\t\t\t\tvar num_vals = values.length\n\t\t\t\t\t\t\tvar step = Math.floor(values.length / 12)\n\t\t\t\t\t\t\tif (index % step == 0) {\n\t\t\t\t\t\t\t\treturn \"tick\"\n\t\t\t\t\t\t\t} else{\n\t\t\t\t\t\t\t\treturn \"\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t// var age_diff = this.state.end_age - this.state.start_age\n\t\t\t\t\t\t\t// var step = age_diff / 12\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}]\n\t\t\t}\n\t\t}\n\n\t\tconst data = {\n\t\t\tlabels: this.state.labels,\n\t\t\tdatasets: datasets\n\t\t};\n\n\n\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<Line\n\t\t\t\t\tdata={data}\n\t\t\t\t\toptions={options}\n\t\t\t\t/>\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default Graph;"]},"metadata":{},"sourceType":"module"}